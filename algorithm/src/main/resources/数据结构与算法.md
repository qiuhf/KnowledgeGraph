# 基本概念

## 评估算法优劣的核心指标是什么？

- 时间复杂度（流程决定）
- 额外空间复杂度（流程决定）
- 常数项时间（实现细节决定）

##  什么是时间复杂度？时间复杂度怎么估算？

- 常数时间的操作
- 确定算法流程的总操作数量与样本数量之间的表达式关系
- 只看表达式最高阶项的部分

## 时间复杂度的意义？

​        当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是什么，不是最重要的。真正重要的就是最高阶项是什么。

​        这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。

## 额外空间复杂度

​        你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。

> 作为输入参数的空间，不算额外空间。作为输出结果的空间，也不算额外空间。因为这些都是必要的、和现实目标有关的。所以都不算。
>

但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。

## 何为常数时间的操作？

​        如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作。

## 常见的常数时间的操作

- 常见的算术运算（+、-、*、/、% 等）
- 常见的位运算（>>、>>>、<<、|、&、^等）
- 赋值、比较、自增、自减操作等
- 数组寻址操作

>  总之，执行时间固定的操作都是常数时间的操作。反之，执行时间不固定的操作，都不是常数时间的操作

## 如何确定算法流程的总操作数量与样本数量之间的表达式关系？

1. 想象该算法流程所处理的数据状况，要按照最差情况来。
2. 把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。
3. 如果数据量为N，看看基本动作的数量和N是什么关系。

## 算法流程的常数项的比拼方式

​    放弃理论分析，生成随机数据直接测。

> 为什么不去理论分析？
>
> 不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快慢之分的。如位运算的常数时间远小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。

​     所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。

## 算法和数据结构学习的大脉络

1）知道**怎么算**的算法
2）知道**怎么试**的算法

## 如何确定算法流程的时间复杂度？

​       当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。

> 记为：O(忽略掉系数的高阶项)

## 常见的时间复杂度?

   *排名从好到差*：

1. O(1)   
2. O(logN)   
3. O(N)   
4. O(N*logN)   
5. O(N^2)   O(N^3)   …   O(N^K)
6. O(2^N)   O(3^N)   …   O(K^N)
7. O(N!)

## 认识异或运算

  **异或运算**：相同为0，不同为1
  **同或运算**：相同以1，不同为0

> 异或运算就记成无进位相加！

## 栈和队列

​	**栈**：数据先进后出，犹如弹匣
​	**队列**：数据先进先出，好似排队

## 递归

​      递归底层是利用系统**栈**来实现的, 任何递归函数都一定可以改成非递归

>形如: 
>
>`T(N) = a * T(N/b) + O(N^d)`(其中的a、b、d都是常数)
>
>的递归函数，可以直接通过**Master公式**来确定时间复杂度:
>1. 如果 log(b,a) < d，复杂度为O(N^d)
>2. 如果 log(b,a) > d，复杂度为O(N^log(b,a))
>3. 如果 log(b,a) == d，复杂度为O(N^d  * logN)

## 哈希表

   哈希表在使用层面上可以理解为一种集合结构

1. 如果只有key，没有伴随数据value，可以使用`HashSet`结构
2. 如果既有key，又有伴随数据value，可以使用`HashMap`结构

>有无伴随数据，是HashMap和HashSet唯一的区别，底层实际结构是一回事

​     使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是常数时间比较大 

> 放入哈希表的对象
>
> 如果是基础类型，内部按值传递，内存占用是这个对象的大小 
>
> 如果不是基础类型，内部按引用传递，内存占用是8字节

## 有序表

​    有序表在使用层面上可以理解为一种集合结构，有序表把key按照顺序组织起来，而哈希表完全不组织

1. 如果只有key，没有伴随数据value，可以使用`TreeSet`结构
2. 如果既有key，又有伴随数据value，可以使用`TreeMap`结构

> 有无伴随数据，是TreeSet和TreeMap唯一的区别，底层实际结构是一回事

​    红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同

​    有序表在使用时，比哈希表功能多，时间复杂度都是O(logN)

> 放入有序表的对象
>
> 如果是基础类型，内部按值传递，内存占用是这个对象的大小 
>
> 如果不是基础类型，内部按引用传递，内存占用是8字节